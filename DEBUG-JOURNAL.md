# My Debug Journal

- Dec 29, 2019. BIOS 15h E820h call kept set CF, which means error occured. Spent a few hours on that. And it turned out that I just need to use 32-bit instructions and registers. I fixed it by replacing movw, leaw, ... with movl, leal, ... and replacing ax, bx, ... with eax, ebx, .... Still don't know why. I guess _real mode_ isn't always using 16-bit wide data path. It depends on cpus.

- Dec 28, 2019. Continuation from previous day. I couldn't figure out why qemu isn't recoginizing my assembly code output. The output was in the right format("binary") from llvm-objcopy, however it kept saying no bootable record. My time was mainly spent on comparing rust bootloader output with my output and reading about llvm tools like llvm-objcopy and llvm-ar(they are both used in rust bootloader build script). Turned out it kept failing simply because section flag for boot 1st stage has a typo. It was supposed to be "awx" instead of "aws"!!! I just went to re:invent a few weeks ago. That is why it kept showing in header/section table as DATA(read-only) section instead of TEXT(executable).

- Dec 27, 2019. I couldn't figure out how to load my compiled bare-metal(x86-64) assembly code with cargo/rust llvm-tools into qemu. My inspiration of the experiment was from [this rust bootloader](https://github.com/rust-osdev/bootloader). I knew it's failing because SeaBIOS in qemu always report no bootable record found(or something like that). I tried looking into compiled object sections and symbol tables. They looked alright. Then I read rust bootloader code thoroughly and learned that I need to supply qemu with "binary" format file instead of object files. I kept suspecting it was because of some debug symbol created by rust compiler that got into the way. This costed me a few hours.